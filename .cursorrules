# Règles de développement pour Piction.ia.ry

## CONTEXTE DU PROJET
Tu développes **Piction.ia.ry**, une application mobile Flutter de jeu collaboratif où :
- 4 joueurs répartis en 2 équipes s'affrontent
- Chaque équipe a 2 rôles : "Dessinateur" et "Devineur" (alternent à chaque tour)
- Le dessinateur écrit un prompt pour générer une image via StableDiffusion
- Le devineur tente de résoudre le challenge : "Un/Une [INPUT1] Sur/Dans Un/Une [INPUT2]"
- Système de points : 100 points de base, -10 points par régénération d'image, -1 point par mauvaise réponse, +25 points par mot trouvé

## PHILOSOPHIE DE DÉVELOPPEMENT

### SIMPLICITÉ AVANT TOUT
- **Une fonctionnalité = Un écran** : Chaque écran doit avoir un objectif clair et unique
- **Architecture minimale** : Évite la sur-ingénierie, privilégie les solutions directes
- **Code lisible** : Préfère la clarté à la performance prématurée
- **Composants réutilisables** : Crée des widgets custom uniquement quand nécessaire

### STRUCTURE ORGANISATIONNELLE
```
lib/
├── main.dart
├── screens/          # Écrans de l'application
│   ├── home_screen.dart
│   ├── lobby_screen.dart
│   ├── challenge_creation_screen.dart
│   ├── game_screen.dart
│   └── results_screen.dart
├── widgets/          # Composants réutilisables
├── models/           # Modèles de données
├── services/         # Services API et logique métier
├── utils/            # Utilitaires et helpers
└── themes/           # Thème et styles
```

## CONTRAINTES TECHNIQUES

### FLUTTER - PRINCIPES FONDAMENTAUX
- **StatelessWidget** par défaut : N'utilise StatefulWidget que si l'état change vraiment
- **Widget build()** : Garde les méthodes build() courtes et lisibles
- **setState()** : Utilise uniquement pour les changements d'état UI, pas pour la logique métier
- **Controllers** : Utilise les TextEditingController et dispose() correctement
- **Navigation** : Utilise Navigator.push/pop, garde la pile de routes simple

### GESTION DES DONNÉES
- **SharedPreferences** : Pour les données de session légères (préférences utilisateur, scores)
- **Modèles simples** : Classes Dart basiques, évite les ORM complexes
- **État local** : Garde l'état au niveau du widget qui en a besoin

### ASYNCHRONISME
- **async/await** : Utilise pour toutes les opérations réseau
- **FutureBuilder** : Pour afficher les données asynchrones
- **try/catch** : Toujours gérer les erreurs des opérations async
- **Timer.periodic** : Pour le chrono de jeu (5 minutes)

### API ET RÉSEAU
- **http package** : Pour les appels API vers StableDiffusion
- **CachedNetworkImage** : Pour afficher et mettre en cache les images générées
- **Gestion d'erreurs** : Toujours prévoir les cas de réseau lent/indisponible

## ÉCRANS OBLIGATOIRES

### 1. Écran d'accueil (HomeScreen)
- Bouton "Créer une partie"
- Bouton "Rejoindre une partie" 
- Design simple et attractif

### 2. Écran de lobby (LobbyScreen)
- Affichage des 4 joueurs connectés
- Attribution des équipes et rôles
- Bouton "Commencer la partie"

### 3. Écran de création de challenges (ChallengeCreationScreen)
- 4 formulaires : "Un/Une [INPUT1] Sur/Dans Un/Une [INPUT2]"
- Liste des 3 mots interdits par challenge
- Validation et envoi à l'équipe adverse

### 4. Écran de jeu (GameScreen)
- Zone d'affichage de l'image générée
- Zone de saisie pour les réponses du devineur
- Chrono 5 minutes
- Score en temps réel
- Boutons de régénération d'image (max 2 fois)

### 5. Écran de résultats (ResultsScreen)
- Affichage des scores finaux
- Bouton "Rejouer" ou "Retour à l'accueil"

## FONCTIONNALITÉS CRITIQUES

### GESTION DU JEU
- **Timer de 5 minutes** : Arrêt automatique à la fin du temps
- **Système de points** : Calcul en temps réel et affichage
- **Validation des mots** : Vérification que les mots interdits ne sont pas utilisés dans les prompts
- **Alternance des rôles** : Gestion automatique du changement dessinateur/devineur

### INTÉGRATION IA
- **API StableDiffusion** : Génération d'images à partir de prompts
- **Gestion de la latence** : Indicateurs de chargement pendant la génération
- **Régénération** : Maximum 2 fois par challenge, coût de 10 points

### INTERFACE UTILISATEUR
- **Thème cohérent** : Couleurs, polices, et style définis dès le début
- **Responsive design** : Compatible téléphones et tablettes
- **Animations simples** : flutter_staggered_animations pour les transitions
- **Hero animations** : Pour la continuité visuelle entre écrans

## BONNES PRATIQUES DE CODE

### NOMMAGE
- **Fichiers** : snake_case (ex: `game_screen.dart`)
- **Classes** : PascalCase (ex: `GameScreen`)
- **Variables/méthodes** : camelCase (ex: `currentScore`)
- **Constantes** : UPPER_CASE (ex: `MAX_PLAYERS`)

### WIDGETS
```dart
// ✅ BON : Widget simple et focused
class ScoreDisplay extends StatelessWidget {
  final int score;
  const ScoreDisplay({super.key, required this.score});
  
  @override
  Widget build(BuildContext context) {
    return Text('Score: $score');
  }
}

// ❌ MAUVAIS : Widget trop complexe
class ComplexGameWidget extends StatefulWidget {
  // Trop de responsabilités dans un seul widget
}
```

### GESTION D'ÉTAT
```dart
// ✅ BON : État local simple
class TimerWidget extends StatefulWidget {
  @override
  _TimerWidgetState createState() => _TimerWidgetState();
}

class _TimerWidgetState extends State<TimerWidget> {
  Timer? _timer;
  int _seconds = 300; // 5 minutes
  
  @override
  void dispose() {
    _timer?.cancel();
    super.dispose();
  }
}
```

## PACKAGES RECOMMANDÉS
- `http` : Requêtes API
- `cached_network_image` : Cache des images
- `shared_preferences` : Stockage local
- `flutter_staggered_animations` : Animations
- Évite les packages tiers sauf nécessité absolue

## CRITÈRES D'ÉVALUATION
- **Phase 1** : Tous les écrans designés, thème défini, modèles créés
- **Phase 2** : Application fonctionnelle de bout en bout, navigation fluide, règles respectées

## INSTRUCTIONS POUR L'IA

### TOUJOURS
- Commence par le plus simple et itère
- Un seul problème à la fois
- Code compilable à chaque étape
- Commente les parties complexes
- Gère les cas d'erreur

### JAMAIS
- N'ajoute pas de fonctionnalités non demandées
- Ne sur-complique pas l'architecture
- N'oublie pas les dispose() des controllers/timers
- Ne néglige pas la gestion d'erreurs réseau

### ORDRE DE DÉVELOPPEMENT RECOMMANDÉ
1. Structure de base et navigation
2. Modèles de données simples  
3. Écrans statiques avec thème
4. Intégration API StableDiffusion
5. Logique de jeu et timer
6. Polish UI et animations
7. Tests et debugging

Développe toujours en pensant **"Comment puis-je faire plus simple ?"** plutôt que **"Comment puis-je faire plus sophistiqué ?"**